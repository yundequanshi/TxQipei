package com.zuomei.utils;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import com.zuomei.exception.ZMHttpException;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.ArrayList;import java.util.Enumeration;import java.util.List;import java.util.zip.Deflater;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;import java.util.zip.ZipOutputStream;public class ZMFileUtil {    private static final String TAG = "LTFileUtil.java";    /**     * 删除目录或者文件     *     * @param filePath 文件或者路径的全路径（包括文件名部分）     */    public static void delete(String filePath) {        File file = new File(filePath);        // 如果存在在执行删除操作        if (file.exists()) {            // 如果是目录要递归先删除该目录下的文件及子目录才能删除该目录            if (file.isDirectory()) {                if (file.listFiles().length == 0) {                    file.delete();                } else {                    File delFile[] = file.listFiles();                    int count = delFile.length;                    for (int i = 0; i < count; i++) {                        if (delFile[i].isDirectory()) {                            delete(delFile[i].getAbsolutePath());                        }                        delFile[i].delete();                    }                    file.delete();                }            } else { // 如果不是目录，直接删除该文件                file.delete();            }        }    }        public static synchronized void saveDrawable(String filename, Drawable drawable,Context context)			throws ZMHttpException {		BitmapDrawable bd = (BitmapDrawable) drawable;		Bitmap bp = bd.getBitmap();//		String filePath = String.format("%s.png",filename);		FileOutputStream fOut=null;		try {			fOut = context.openFileOutput(filename,Context.MODE_PRIVATE);		} catch (FileNotFoundException e1) {			throw new ZMHttpException(String.format("保存模块图标出错：",e1.getMessage()));		}		bp.compress(Bitmap.CompressFormat.PNG, 100, fOut);		try {			if (fOut != null) {				fOut.flush();			}		} catch (IOException e) {			throw new ZMHttpException(String.format("保存模块图标出错：",e.getMessage()));		}		try {			if (fOut != null) {				fOut.close();			}		} catch (IOException e) {			throw new ZMHttpException(String.format("保存模块图标出错：",e.getMessage()));		}	}	 	public static synchronized Drawable loadDrawable(String fileName,Context context) throws ZMHttpException {				FileInputStream fileInputStream =null;		Drawable drawable = null;		try {			fileInputStream =context.openFileInput(fileName);			Bitmap bmp = BitmapFactory.decodeStream(fileInputStream);			drawable = new BitmapDrawable(context.getResources(), bmp);		} catch (FileNotFoundException e) {			throw new ZMHttpException("加载图标失败，没有找到文件");		}finally{			try {				fileInputStream.close();			} catch (IOException e) {				e.printStackTrace();				throw new ZMHttpException("加载图标失败，关闭文件流失败！");			}		}		return drawable;	}	//	public static synchronized Drawable loadDrawable(LTMetroModel module,Context context) {//		//		String metroFileName = String.format("Metro_%s.png", module.code);//		String menuActiveIconFileName = String.format(//				"Menu_Active_%s.png", module.code);//		String menuUnActiveIconFileName = String.format(//				"Menu_UnActive_%s.png", module.code);//		//		Drawable.createFromPath()//		FileInputStream fileInputStream =null;//		Drawable drawable = null;//		try {//			fileInputStream =context.openFileInput(filename);//			Bitmap bmp = BitmapFactory.decodeStream(fileInputStream);//			drawable = new BitmapDrawable(bmp);//		} catch (FileNotFoundException e) {//			e.printStackTrace();//			error.errorMessage  = e.getMessage();//			return null;//		}finally{//			try {//				fileInputStream.close();//			} catch (IOException e) {//				e.printStackTrace();//			}//		}//		return drawable;//	}    /**     * 创建多级目录     *     * @param path 目录     */    public static void makeDirsByPath(String path) {        File dirFile = null;        dirFile = new File(path);        if (!dirFile.exists()) {            dirFile.mkdirs();        }        dirFile = null;    }    /**     * 创建多级目录     *     * @param filePath 文件全路径     */    public static void makeDirsByFilePath(String filePath) {        String path = filePath.substring(0, filePath.lastIndexOf("/"));        makeDirsByPath(path);    }    /**     * 将Bitmap保存成PNG文件     *     * @param bitmap   位图     * @param filePath 文件的全路径（包括文件名部分）     * @throws IOException IO异常     */    public static void saveBitmapToFile(Bitmap bitmap, String filePath)            throws IOException {        makeDirsByFilePath(filePath);        File bitmapFile = new File(filePath);        BufferedOutputStream bos = new BufferedOutputStream(                new FileOutputStream(bitmapFile));        bitmap.compress(Bitmap.CompressFormat.PNG, 80, bos);        bos.flush();        bos.close();    }    /**     * 压缩目录下的所有文件,只从srcDir的末级目录开始压缩     *     * @param srcDir      源目录     * @param zipFileName 压缩后的ZIP文件全路径     * @return 如果返回true，压缩成功，否则反之     * @throws IOException 抛出IO异常     */    public static boolean zipFiles(String srcDir, String zipFileName,                                   boolean containCatalog) throws IOException {        File fileFolder = new File(srcDir);        String foderPrefix = srcDir.substring(0, srcDir.lastIndexOf("/"));        MLToolUtil.DebugInfo(TAG, String.format("目录前缀：%s", foderPrefix));        if (fileFolder.isDirectory() && fileFolder.exists()) {            // 取得所有文件            List<File> files = getSubDictionaryFiles(srcDir);            // 如果有文件，将进行压缩            if (files.size() > 0) {                makeDirsByFilePath(zipFileName);                ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(                        zipFileName));                zos.setLevel(Deflater.BEST_COMPRESSION);                ZipEntry zipEntry = null;                byte[] buffer = new byte[1024];                int readlen = 0;                for (File file : files) {                    MLToolUtil.DebugInfo(TAG,                            String.format("file.getAbsolutePath is %s",                                    file.getAbsolutePath()));                    if (containCatalog) {                        zipEntry = new ZipEntry(file.getAbsolutePath().replace(                                foderPrefix, ""));                    } else {                        zipEntry = new ZipEntry(file.getAbsolutePath().replace(                                srcDir + "/", ""));                    }                    zipEntry.setSize(file.length());                    zipEntry.setTime(file.lastModified());                    zos.putNextEntry(zipEntry);                    InputStream is = new BufferedInputStream(                            new FileInputStream(file));                    while ((readlen = is.read(buffer, 0, 1024)) != -1) {                        zos.write(buffer, 0, readlen);                    }                    is.close();                }                zos.close();                return true;            }        }        return false;    }    /**     * 解压缩函数     *     * @param zipFilePath 压缩文件的全路径     * @param desDir      解压缩的目标目录     * @return 如果返回true，压缩成功，否则反之     * @throws IOException 抛出IO异常     */    @SuppressWarnings("unchecked")    public static boolean unzipFiles(String zipFilePath, String desDir)            throws IOException {        File file = new File(zipFilePath);        if (file.exists()) {            ZipFile zipFile = new ZipFile(zipFilePath);            Enumeration<ZipEntry> zipList = (Enumeration<ZipEntry>) zipFile                    .entries();            ZipEntry zipEntry = null;            byte[] buffer = new byte[1024];            while (zipList.hasMoreElements()) {                zipEntry = (ZipEntry) zipList.nextElement();                if (zipEntry.isDirectory()) {                    continue;                }                MLToolUtil.DebugInfo(TAG, String.format("zipEntry name is %s",                        zipEntry.getName()));                String unzipAbsFilePath = desDir + "/" + zipEntry.getName();                makeDirsByFilePath(unzipAbsFilePath);                OutputStream os = new BufferedOutputStream(                        new FileOutputStream(unzipAbsFilePath));                InputStream is = new BufferedInputStream(                        zipFile.getInputStream(zipEntry));                int readlen = 0;                while ((readlen = is.read(buffer, 0, 1024)) != -1) {                    os.write(buffer, 0, readlen);                }                is.close();                os.close();            }            zipFile.close();            return true;        }        return false;    }    /**     *     * @param zipFilePath     * @param desDir     * @param isDelete     * @return     * @throws IOException     */    /**     * 解压缩函数     *     * @param zipFilePath 压缩文件的全路径     * @param desDir      解压缩的目标目录     * @param isDelete    解压完成后是否删除ZIP文件     * @return 如果返回true，压缩成功，否则反之     * @throws IOException 抛出IO异常     */    public static boolean unzipFiles(String zipFilePath, String desDir,                                     boolean isDelete) throws IOException {        boolean res = unzipFiles(zipFilePath, desDir);        if (res) {            if (isDelete) {                delete(zipFilePath.substring(0, zipFilePath.lastIndexOf("/")));            }            return true;        }        return false;    }    /**     * 获取目录下的所有文件及子目录     *     * @param baseDir 根目录     * @return 返回一个File的列表     */    private static List<File> getSubDictionaryFiles(String baseDir) {        File baseFile = new File(baseDir);        if (baseFile.exists() && baseFile.listFiles().length > 0) {            File files[] = baseFile.listFiles();            List<File> fileList = new ArrayList<File>();            for (File file : files) {                if (file.isFile()) {                    fileList.add(file);                }                if (file.isDirectory()) {                    MLToolUtil.DebugInfo(TAG,                            String.format("sub dictionary is %s",                                    file.getAbsolutePath()));                    fileList.addAll(getSubDictionaryFiles(file                            .getAbsolutePath()));                }            }            return fileList;        }        return null;    }    public static void LogToFile(String fileName, String content) {        makeDirsByFilePath(fileName);        FileOutputStream outStream = null;        String msg = content + "\n";        try {            outStream = new FileOutputStream(fileName, true);            outStream.write(msg.getBytes());        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } finally {            if (outStream != null) {                try {                    outStream.close();                } catch (IOException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }        }    }}